% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/createEPMgrid.R
\name{createEPMgrid}
\alias{createEPMgrid}
\title{Create epmGrid object}
\usage{
createEPMgrid(
  spDat,
  resolution = 50000,
  method = "centroid",
  cellType = "hexagon",
  coverCutoff = 0.1,
  retainSmallRanges = TRUE,
  extent = "auto",
  percentWithin = 0,
  checkValidity = FALSE,
  crs = NULL,
  nThreads = 1,
  template = NULL,
  nGroups = 1,
  verbose = FALSE
)
}
\arguments{
\item{spDat}{a list of polygon objects (sf or sp), named with taxon names. Alternatively, 
a set of occurrence records. See details for more information.}

\item{resolution}{vertical and horizontal spacing of grid cells, in units 
of the polygons' or points' projection.}

\item{method}{approach used for gridding. Either \code{centroid} or \code{areaCutoff}. See details below.}

\item{cellType}{either \code{hexagon} or \code{square}. See details below.}

\item{coverCutoff}{the percent that a species range must cover a grid cell to be considered present.}

\item{retainSmallRanges}{boolean; should small ranged species be dropped or preserved.
See details.}

\item{extent}{if 'auto', then the maximal extent of the polygons will be used. 
If not 'auto', can be a SpatialPolygon, sf object, or raster, in which case the resulting epmGrid
will be cropped and masked with respect to the polygon, or a spatial coordinates object, 
from which an extent object will be generated, or a numeric vector of length 4 
with minLong, maxLong, minLat, maxLat. If 'interactive', then an interactive plot
will appear in which the user can draw the desired polygon extent. That extent will then be returned.}

\item{percentWithin}{The percentage of a species range that must be within the defined extent in order
for that species to be included. This filter can be used to exclude species whose range barely enters
the area of interest. The default value of 0 will disable this filter. If \code{extent == 'auto'},
then this filter will also have no effect, as the extent is defined by the species' ranges.}

\item{checkValidity}{if \code{TRUE}, then check polygon validity and repair if needed, 
using sf::st_make_valid and the lwgeom package.}

\item{crs}{if supplying occurrence records in a non-spatial format, then you must specify the crs.
For unprojected long/lat data, you can simply provide \code{crs = 4326}.}

\item{nThreads}{if > 1, then employ parallel computing.}

\item{template}{an object of class \code{SpatRaster} or \code{RasterLayer} that can be used to 
get extent and resolution. If \code{cellType = 'square'}, then the template will be used as the 
reference grid.}

\item{nGroups}{break up the grid into this many groups for processing. This will alleviate memory 
usage for datasets that are very high resolution (not relevant for large numbers of species).}

\item{verbose}{if TRUE, list out all species that are dropped/excluded, rather than counts.}
}
\value{
an object of class \code{epmGrid}. If \code{extent = 'interactive'}, then a polygon is returned.
}
\description{
Takes a list of polygons or point occurrences and creates a epmGrid object.
}
\details{
If \code{cellType = 'hexagon'}, then the grid is made of polygons via the sf package.
	If \code{cellType = 'square'}, then the grid is a raster generated via the terra package.
	Hexagonal cells have several advantages, including being able to be of different sizes (if the grid is in 
	unprojected long/lat), and may be able to more naturally follow coastlines and non-linear features.
	However, the raster-based square cells will be much less memory intensive for high resolution datasets. 
	Choice of grid type matters more for spatial resolution (total number of cells), than for number of species.


	In the polygon-to-grid conversion process, two approaches are implemented. 
	For \code{method = 'centroid'}, a range polygon registers in a cell if the polygon 
	overlaps with the cell centroid. 
	For \code{method = 'areaCutoff'}, a range polygon registers in a cell if it covers that cell by 
	at least \code{coverCutoff} fraction of the cell.
	If \code{retainSmallRanges = FALSE}, then species whose ranges are so small that no 
	cell registers as present will be dropped. If \code{retainSmallRanges = TRUE}, then the 
	cell that contains the majority of the the small polygon will be considered as present, even if it's a 
	small percent of the cell.

	If \code{retainSmallRanges = TRUE}, and an extent is provided, then species may still be dropped if they
	fall outside of that extent.

	In interactive mode for defining the extent, the user can draw a bounding polygon on a 
	map. The drawn polygon will then be printed to the console so that the user can provide 
	that bounding polygon in future calls as the extent.
	
	If input data consist of occurrence records rather than polygons, then a couple of formats are possible:
    \enumerate{
	  \item You can provide a list of species-specific spatial point objects. 
 	  \item You can provide a single spatial object, where points have a taxon attribute.
	  \item You can provide a list of non-spatial species-specific dataframes.
	  \item You can provide a single non-spatial dataframe.
	}
	
	For options (1) and (3), the taxon names must be provided as the list names.
	For options (3) and (4), the columns must be 'taxon', 'x' and 'y' (or 'long', 'lat').
	For options (3) and (4), as these are non-spatial, you must provide a crs object to the
	\code{crs} argument, so that the function knows what projection to use.

	Any SpatialPolygon or SpatialPoints objects are converted to objects of class \code{sf}.

    For \code{extent = 'interactive'}, you can additionally specify some bounding coordinates.
    This can be helpful if the interactive map is too broad in extent, making it difficult to draw
    the extent that you want. Instead, specify \code{extent = list('interactive', c(xmin, xmax, ymin, ymax))}.
	In interactive mode, the basemap is from \url{www.naturalearthdata.com}.
}
\examples{
library(sf)
# example dataset: a list of 24 chipmunk distributions as polygons
head(tamiasPolyList)

# hexagonal grid
tamiasEPM <- createEPMgrid(tamiasPolyList, resolution = 50000, 
	cellType = 'hexagon', method = 'centroid')
tamiasEPM

# square grid
tamiasEPM2 <- createEPMgrid(tamiasPolyList, resolution = 50000, 
	cellType = 'square', method = 'centroid')
tamiasEPM2

#######
# With point occurrences
## demonstrating all possible input formats

# list of sf spatial objects
spOccList <- lapply(tamiasPolyList, function(x) st_sample(x, size = 10, type= 'random'))
tamiasEPM <- createEPMgrid(spOccList, resolution = 100000, cellType = 'hexagon')

# list of coordinate tables
spOccList2 <- lapply(spOccList, function(x) st_coordinates(x))
tamiasEPM <- createEPMgrid(spOccList, resolution = 100000, cellType = 'square')

# single table of coordinates
spOccList3 <- spOccList2
for (i in 1:length(spOccList3)) {
	spOccList3[[i]] <- cbind.data.frame(taxon = names(spOccList3)[i], spOccList3[[i]])
	colnames(spOccList3[[i]]) <- c('taxon', 'X', 'Y')
}
spOccList3 <- do.call(rbind, spOccList3)
rownames(spOccList3) <- NULL
spOccList3[, "taxon"] <- as.character(spOccList3[, "taxon"])
tamiasEPM <- createEPMgrid(spOccList, resolution = 100000, cellType = 'square')

# a single labeled spatial object
spOccList4 <- st_as_sf(spOccList3[, c("taxon", "X", "Y")], coords = c("X","Y"), 
crs = st_crs(spOccList[[1]]))
tamiasEPM <- createEPMgrid(spOccList, resolution = 100000, cellType = 'square')



}
\author{
Pascal Title
}
